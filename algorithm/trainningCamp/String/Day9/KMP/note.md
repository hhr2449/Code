设定原字符串为txt，长度为m；模式字符串为par，长度为n
* 暴力算法：
外层循环用于遍历txt，代表字符串的起始字符，对于每个特定起始字符的情况，使用一个循环进行匹配
时间复杂度是o(mn)
* KMP算法：
  * 思路：在暴力算法中，每次匹配都要从头开始，相当于上次匹配的结果没有得到利用，所以我们就应该像办法来充分利用已经得到匹配的部分
  * 使用最长公共前后缀：每次匹配失败不将par中的指针归零并且将txt中的指针后移一位，而是寻找已经匹配的部分字符串的最长公共前后缀，使用par中的最长公共前缀和txt中的最长公共后缀进行对齐，然后以此为基础进一步进行收缩
  * 正确性证明：
  假设上次的失败匹配的起始点为i，失败后使用最长公共前后缀进行对齐的起点为a，那么只需要证明[i,a)这个区间内的元素为起始点的子串不可能形成匹配即可
  可以使用反证法
    ![](https://raw.githubusercontent.com/hhr2449/pictureBed/main/img/微信图片_2025-08-07_190053_402.jpg)
  ![](https://raw.githubusercontent.com/hhr2449/pictureBed/main/img/微信图片_2025-08-07_190105_417.jpg)
  * 具体思路：
  1. 构造前缀表：可以发现，最长公共前后缀其实只和par这个字符串有关，这样就可以构造前缀表next，next[i]表示par中长度为i的子串中最长公共前后缀的长度（其实就是par[0,i-1]中最长公共前后缀的长度）
      * 为什么要定义next[i]为[0,i-1]中最长公共前后缀的长度：因为这样设置，在模式串的第i位和txt失配的时候，指针j就应该回溯到next[j]
      * 如何求next数组：
        1. 设定两个指针，j为前指针，指向的是前缀的结束字符，i为后指针，指向的是当前所求的字符串的结束字符
        2. 初始化j=-1,i=0
        3. 如果j==-1或者i和j指向的字符相同，则先移动i,j，然后next[i] = j（注意这里一定要先移动，因为[0,i]这个字符串对应的是mext[i+1]）
        4. 如果不匹配，则回退j=next[j]
  2. 进行遍历，使用两个指针i,j，i用与txt字符串，j用于par字符串，如果i和j指向的字符相同，则同时前进，如果不相同，则i不动，同时将j进行回退，回退到next[j]处
   ！！注意有可能出现指针j移动到-1的情况，这是由于回退的时候回退到了0（也就是没有公共前后缀），然后发现0处也不匹配，此时根据0处的默认值会出现j=-1,此时应该同时移动指针i,j（因为如果第一个字符都不匹配则应该继续尝试匹配第一个字符）
   为什么next[0]要初始化为-1，目的就是特殊标示出第一个字符都不匹配的情况（即j=-1），注意不能将next[0]设置为0，因为这样没有办法特殊处理这种情况，会造成死循环（相当于这是状态回退的边界）
   除0外其他位置next[i]=0，仅说明下一步 j 要回到第0位去进行下一轮的判断（也就是接下来要比较t[0]和s[i]）。
   next[0]=-1，表示的是 j 下一位没有地方可回溯了，因为子串的第0位和母串的第 i 位也不匹配，此时只能移动指针i。



* 可以利用next数组求解最小公共前后缀
  ```cpp
  vector<int> getNext(string& s) {
        int n = s.size();
        vector<int> next(n+1);
        int i = 0;
        int j = -1;
        next[0] = -1;
        while(i < n) {
            if(j == -1 || s[i] == s[j]) {
                i++;
                j++;
                next[i] = j;
            }
            else {
                j = next[j];
            }
        }
        return next;
    }
    //!求解最小公共前后缀
    //!这里利用了next数组，next[i]代表[0,i-1]这个子串的最大公共前后缀长度
    //!实际上，s的最大公共前后缀的前缀的公共前后缀也是s的公共前后缀，而且长度一定会变小
    //!这样可以利用next[n]->next[next[n]]->……这样不断迭代，寻找这个链条中的最小正整数即为最小公共前后缀
    int minCommonPrefixSuffixLinear(string& s) {
        //获取next数组
        vector<int> next = getNext(s);
        for(int i : next) {
            cout << i << ' ';
        }
        int res = INT_MAX, i = s.size();
        while(i > 0) {
            if(next[i] > 0) {
                res = min(res, next[i]);
            }
            else {
                break;
            }
            i = next[i];
        }
        return res == INT_MAX ? 0 : res;

    }
    ```