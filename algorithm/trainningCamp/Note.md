## 数组理论基础
数组是存放在连续内存空间中相同数据类型的集合
* 数组的下标从零开始
* 数组中的元素在内存中是连续的

在改变数组时，不能直接删除元素，只能覆盖，要想实现删除元素必须将后面的元素向前移动

* 在cpp中，二维乃至多维数组的储存也是连续的
* 在java中，数组可以看作一个特殊的对象，能够获取到的是对象的引用，而多维数组可以看作是数组对象的数组，此时储存就不一定连续了


双指针法：原本需要两个指针进行遍历，简化为一个指针进行遍历，一般需要先确定遍历的那根指针要遍历的量是什么，然后再根据题目的特点进行简化
关键在于确定的遍历指针单向移动的前提下，另一个指针一定是单向的，比如长度最小的子数组，确定右边界为遍历的量，那么在确定[a,b]是一个满足条件的子串的前提下，右指针继续向右遍历，左值针一定也要向右，否则长度一定会变长，利用这个特点，在右指针位置改变的时候，左值针不需要从最左边开始遍历，只需要在原本左值针的位置的基础上继续向右即可
实质上就是一种剪枝，先将右指针右移直到大于或等于指定值，然后将左值针左移，直到刚好小于指定值，此时[l1-1,r1]就是以r1为右端点的最短区间，接着将右指针右移直到满足条件，中间跳过的右指针位置就是一定不可能超过当前最优的位置（因为此时区间长度已经大于等于当前最优，但是仍然不满足），直到[l1,r2]满足条件，对于r2为右端点的情况可能可以更优，但是左值针一定要向右移，所以再将左值针向右移一直到刚好不满足条件，对于最大值进行更新，继续重复以上操作
要搞清楚：
1. 窗口里装的是什么
2. 选择哪个指针来遍历什么量
3. 另一个指针位置是否单调


在一个二维平面上，有一条上边（例如 y = 1）和一条下边（例如 y = 0），它们分别各有一些点。这些点可以用横坐标来表示：

上边的点：A = [a₁, a₂, ..., aₙ]，每个点为 (aᵢ, 1)

下边的点：B = [b₁, b₂, ..., bₘ]，每个点为 (bⱼ, 0)

你的任务是：
从 A 和 B 中各取一个点，使得这两个点之间的欧几里得距离最小，输出这最小距离。

使用双指针，对于A,B各设置一个指针，初始指向0号位置，之后指针指向的值哪个更小，就将哪个指针向右移动
证明：
首先可以知道A,B中的每一个点都会被扫过一遍
对于距离最近的两个点a,b，它们对应的值a*,b*，不妨设a* < b*，那么一定会满足[a*,b*]之间没有其他点，那么假设(a,b)这个点对不会被选到，那么当A的指针指向a的时候，B的指针一定指向b之后的点，否则根据移动的规则B的指针最终一定移动到b，但是这样此时A和B的指针之间就隔了一个点b，这是不符合移动规则的，所以出现矛盾，则(a,b)点对一定会被选到



## 哈希表

通过建立key和value之间的映射实现快速的增删改查的一种数据结构

实际上是使用哈希函数将Key直接映射到储存key对应的value的地址，从而实现直接获取value

可以将哈希表看成是一个数组，里面储存了**键值对**，可以通过哈希函数将key直接映射到数组的下标，从而直接获取value

比如：

![image-20250730213959521](https://raw.githubusercontent.com/hhr2449/pictureBed/main/img/image-20250730213959521.png)

这里的关键字就是id，这些id刚好可以和数组的下标实现一一对应，所以设置哈希函数为H(key) = key，这样如果我想要查询某个id的学生姓名就不需要遍历数组来一个个查找，只需要直接访问数组中下标为id的位置即可

![image-20250731100451494](https://raw.githubusercontent.com/hhr2449/pictureBed/main/img/image-20250731100451494.png)

这里的id并不是从0开始，那么我们可以设置散列函数为H(key)=key-100，这样就可以将key直接映射到数组的下标

### 构造散列函数

* 直接定址法：使用线性函数作为哈希函数，是用于key基本连续的情况

* 除留余数法：H(key)=key%p，这样得到的结果一定在[0, p)这个范围里面，可以实现将不连续的key映射到一段连续的空间

  这里的p一般取小于等于表长的最大质数，这样可以减少哈希冲突

  如果取的是合数，那么对于其因数的倍数，取模之后得到的结果一定也是因数的倍数，这样会导致哈希冲突的可能性增加

  ![image-20250731102650010](https://raw.githubusercontent.com/hhr2449/pictureBed/main/img/image-20250731102650010.png)



### 哈希冲突

可能会出现多个key经过散列函数映射到同一个值得情况，这样就是哈希冲突

出现哈希冲突会影响哈希表的性能（因为当查找冲突的key的时候需要额外的查找）

影响冲突发生的因素：

1. 散列函数的选取
2. 装填因子：$\alpha(装填因子)=\frac{n(表中元素数)}{m(表长)}$装填因子越大，发生冲突的可能性越大，但是空间利用率会提高

#### 冲突处理

1. 开放定址法

   冲突之后将元素放在表中空出来的位置

   1. 线性探测法：冲突后依此探测下一个位置，直到找到空闲的位置，表尾的下一个位置是表首

      使用这种方法构造散列表后，想要取一个key对应的value就需要通过key来获取一个位置，然后检查这个位置中键值对的key是否是指定的，如果不是就依次继续向下搜索，直到找到；如果直到空都没有找到，那么说明这个元素不存在

      删除元素：首先先找到对应的元素，但是注意此时不能够直接将该位置的元素删除掉，如果直接删除，那么可能导致后面的元素的搜索路径被截断。一般会给这个位置打上一个特殊的标签（比如说设置为-1），用来表示这个位置已经被删除。

   2. 平方探测法：冲突时按照$+1^2,-1^2,+2^2,-2^2,+3^2,-3^2……$的顺序进行探测，这样可以避免线性探测中的聚集问题

      一般将表长设置为4k+3的质数，这样可以保证平方探测可以探测到所有位置

2. 链表法：将所有映射到同一个位置的关键字放在一个单链表中，数组中的每一个元素就是链表的头指针

### 增删改查的复杂度比较

|          | 数组 | 链表 | 哈希表 |
| :------: | :--: | :--: | :----: |
| 增加元素 | o(1) | o(1) |  o(1)  |
| 查询元素 | o(n) | o(n) |  o(1)  |
| 删除元素 | o(n) | o(n) |  o(1)  |

数组和链表想要查询到某一个元素，必须要进行遍历，而哈希表只需要将key放入哈希函数中，就可以直接得到value所处的地址，这样就可以直接获取

c++中常使用`unorder_map,map,mutimap`
其中unorder_map的底层是哈希表，key是无序的，查找和插入的效率均为常数级
map和mutimap的底层是红黑树，key是有序的，查询和插入删除的效率为logn级
如果访问没有插入过的key，那么会自动插入一个具有key和value的默认值的键值对

当遇到需要判断某个元素是否出现过的时候可以使用哈希法