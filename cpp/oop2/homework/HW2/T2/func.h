#pragma once
#include"Test.h"
Test f1(Test t){
    t.print("a");
    return t;
}
//f1分析：
//1.将a传入，调用拷贝构造函数，创建一个a的临时对象（即形参t）传入函数中
//2.调用print函数，输出a.buf的地址
//3.将值返回：使用移动构造函数，创建一个临时对象（不妨称为temp，实际是没有名字的），将t的值传入临时对象中，同时将t1的buf置空
//4.temp被返回，通过移动构造传给A（因为这里的返回值是右值，会触发移动构造）
//5.t和temp被析构

//!三个关键点：
//1.传参：传参是会调用拷贝构造函数，将实参拷贝一份出来给形参
//2.返回值：编译器会优先将返回值视为右值，在返回值的时候会尝试调用移动构造函数，创建出一个临时的对象，然后将实参的值赋给临时对象，然后将临时对象返回
//3.析构：传参时创建的实参副本t和返回值时创建的临时对象temp都会调用析构函数进行释放
//!另一个例子
// Test f1(Test t){
//     t.print("a");
//     Test temp(std::move(t));
//     return temp;
// }
//这个例子中将t通过移动构造传递给临时变量temo，然后将temp返回，所以会出现三次移动，三次析构

//!补充：使用引用的方式传参和返回
//1.如果参数通过引用的方式传入而不是值传递，那么在传入参数的时候就不会调用拷贝构造函数，而是直接将实参传入
//2.同时如果返回值通过引用的方式返回，那么在返回值的时候就不会调用移动构造函数，而是直接将返回值返回
//3.如果返回值是引用，那么A就会直接接受引用，不会调用构造函数，即此时A和传入的实参a是同一个东西
//所以为什么传参时喜欢用引用而不是值，使用引用就可以免去传参和返回值时两次构造和析构的开销，
//!注意：不要返回临时变量的引用，因为临时变量在函数结束后就会被析构
Test& f2(Test& t){
    t.print("b");
    return t;
}
//与f1对比，f2传参和返回都是引用，所以不会有构造和析构
void f3(Test& t1, Test& t2){
    Test temp = (move(t1));
    t1 = move(t2);
    t2 = move(temp);
}
//使用移动赋值函数